# Goroutine

Goroutine（也称为Go程序）可以被看做是承载可被并发执行的代码块的载体。它们由Go语言的运行时系统调度，并依托操作系统线程（又称内核线程）来并发地执行其中的代码块。

在 Go 程序当中，Go 语言的运行时（runtime）系统会帮助我们自动地创建和销毁系统级的线程。这里的系统级线程指的就是我们刚刚说过的操作系统提供的线程。

对应的用户级线程指的是架设在系统级线程之上的，由用户（或者说我们编写的程序）完全控制的代码执行流程。用户级线程的创建、销毁、调度、状态变更以及其中的代码和数据都完全需要我们的程序自己去实现和处理。

Goroutine 代表着并发模型中的用户级线程。

Go 语言拥有强大的用于调度 goroutine、对接系统级线程的调度器。 调度器主要负责统筹调配 Go 并发编程模型中的三个主要元素，即：
* G（goroutine）: 用户级线程。
* M（machine）: 系统级线程。
* P（processor）: 一种可以承载若干个 G，且能够使这些 G 适时地与 M 进行对接，并得到整整运行的中介。



### go 函数
每条go语句一般都会携带一个函数调用，这个被调用的函数常常被称为go函数。而主 goroutine 的 go 函数就是那个作为程序入口的 main 函数。

go 函数真正被执行的时间，总会与其所属的 go 语句被执行的时间不同。   
当程序执行到一条 go 语句的时候，Go 语言的运行时系统，会先试图从某个存放空闲的 G 的队列中获取一个 G（也就是 goroutine），它只有在找不到空闲 G 的情况下才会去创建一个新的 G。已存在的 goroutine 总是会被优先复用。



### 协程
* 创建 G 的成本也是非常低的。创建一个 G 并不会像新建一个进程或者一个系统级线程那样，必须通过操作系统的系统调用来完成，在 Go 语言的运行时系统内部就可以完全做到了，更何况一个 G 仅相当于为需要并发执行代码片段服务的上下文环境而已。
* 在拿到了一个空闲的 G 之后，Go 语言运行时系统会用这个 G 去包装当前的那个go函数，然后再把这个 G 追加到某个存放可运行的 G 的队列中。
* 可运行的队列中的 G 总是会按照先入先出的顺序，很快地由运行时系统内部的调度器安排运行。虽然很快，但是准备工作不可避免，还会有时间开销。因此，go 函数的执行时间总是会"明显"滞后于它所属的go语句的执行时间。
* 只要go语句本身执行完毕，Go 程序完全不会等待go函数的执行，它会立刻去执行后边的语句。这就是所谓的异步并发地执行。
* 一旦主 goroutine 中的代码（也就是main函数中的那些代码）执行完毕，当前的 Go 程序就会结束运行。如果在 Go 程序结束的那一刻，还有 goroutine 未得到运行机会，那么它们中的代码也就不会被执行了。
* Go 语言并不会去保证 goroutine 会以怎样的顺序运行。由于主 goroutine 会与我们手动启用的其他 goroutine 一起接受调度，又因为调度器很可能会在 goroutine 中的代码只执行了一部分的时候暂停，以期所有的 goroutine 有更公平的运行机会。所以哪个 goroutine 先执行完、哪个 goroutine 后执行完往往是不可预知的，除非我们使用了某种 Go 语言提供的方式进行了人为干预。



### 协程等待










### 进程



### 线程
线程总是在进程之内。

主线程：每个进程的第一个线程都会随着该进程的启动而被创建，它是所属进程的主线程。

一个进程至少会包含一个线程。如果一个进程只包含了一个线程，那么代码将被串行执行。  

如果一个进程中包含了多个线程，那么其中的代码就可以被并发地执行。除了进程的第一个线程之外，其他的线程都是由进程中已存在的线程创建出来的。
