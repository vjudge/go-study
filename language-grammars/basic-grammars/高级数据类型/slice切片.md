# 切片类型

切片（slice）是对数组一个连续片段的引用，是**引用类型**。但自身是结构体，值拷贝传递。

切片（Slice）与数组一样，也是可以容纳若干类型相同的元素的容器。与数组不同的是，无法通过切片类型来确定其值的长度。每个切片值都会将数组作为其底层数据结构。我们也把这样的数组称为切片的底层数组。 

不同长度的切片值是有可能属于同一个类型的。相对的，不同长度的数组值必定属于不同类型。
切片表达式的求值结果会是切片类型的，且其元素类型与被“切片”的值的元素类型一致。

切片的长度可以自动随着其中元素数量的增长而增长，但不会随着元素数量的减少而减少。



### 切片的数据结构
```go
type slice struct { 
	array unsafe.Pointer //指向存放数据的数组指针 
	len int //长度有多大 
	cap int //容量有多大 
}
```



### 声明: type slice []type
```go
// 切片类型属于引用类型。它的零值即为nil，即空值。如果我们只声明一个切片类型的变量而不为它赋值，那么该变量的值将会是nil。
var slice []int // nil
var slice []string
```


### 初始化：make([]type, len, cap)
len 是长度，cap 是容量。省略 cap 时，cap = len。
```go
slice = make([]int, len, cap)
// 赋值
var slice = []int{1, 2, 3}
```


### 切片表达式
切片表达式的求值结果相当于以元素下界索引和元素上界索引作为依据从被操作对象上“切下”而形成的新值.被“切下”的部分不包含元素上界索引指向的元素。
```go
arr2 := [...]int{9, 8, 7, 6, 5, 4, 3, 2, 1, 0} // 数组
slice5 := arr[start:end]
slice6 := arr[:end]        
slice7 := arr[start:]     
slice8 := arr[:] // 所有值
slice9 := arr[:len(arr)-1] // 去掉切片的最后一个元素
```


### append(slice, elem)
往切片中添加元素。



### len(slice)
返回切片的长度。



### cap(slice)
返回切片的容量。   
* 一个切片的容量可以被看作是透过这个切片窗口最多可以看到的底层数组中元素的个数。  
* 在底层数组不变的情况下，切片代表的窗口可以向右扩展，直至其底层数组的末尾。  
* 一个切片值的容量即为它的第一个元素值在其底层数组中的索引值与该数组长度的差值的绝对值。（切片表达式求值结果的切片值的长度总是为元素上界索引与元素下界索引的差值。）
```go
array := [...]int{0, 1, 2, 3, 4, 5, 6, 7}
slice := array[2:5] // [2, 3, 4]
len(slice) // 3
cap(slice) // 6  --- len(array) - 2
```



### 切片容量扩容
一旦一个切片无法容纳更多的元素，Go 语言就会扩容，但并不会改变原来切片，而是生成一个容量更大的切片，然后将所有元素和新元素都拷贝到新切片中。    
Go 中切片扩容的策略是这样的： 
* 如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量。 
* 如果切片元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，新容量会被不断调整（即不断与1.25 相乘），直到结果不小于原长度要追加的元素数量之和。














### 切片和数组的区别
* 切片：初始化不指定长度，是可变长的
* 数组：初始化指定长度

















