# 通道类型

通道（Channel）是Go语言中一种非常独特的数据结构。它可用于在不同Goroutine之间传递类型化的数据，并且是并发安全的。这也是 Go 语言自带的、唯一可以满足并发安全性的类型。



### 声明
通道表示方法如下所示。左边是代表通道类型的关键字 chan，而右边则是一个可变的部分，即代表该通道类型允许传递的数据的类型（或称通道的元素类型）。这两部分之间需要以空格分隔。
```
chan T
```


### 初始化
与其它的数据类型不同，我们无法表示一个通道类型的值。因此，我们也无法用字面量来为通道类型的变量赋值。我们只能通过调用内建函数make来达到目的。
```
// 第一个参数: 代表将被初始化的值的类型的字面量（比如chan int）
// 第二个参数: 通道的容量，代表着通道值中可以暂存的数据的个数。  
ch1 := make(chan string, cap)
```


### 缓冲通道
当容量大于 0 时，称通道为缓冲通道。


### 非缓冲通道
当容量为 0 时，称通道为非缓冲通道。  
发送方在向通道值发送数据的时候会立即被阻塞，直到有某一个接收方已从该通道值中接收了这条数据。
```
make(chan int, 0)
```


### 通道说明
* 暂存在通道值中的数据是先进先出的，即：越早被放入（或称发送）到通道值的数据会越先被取出（或称接收）。
* 通道中的各个元素都是严格地按照发送的顺序排列，先被发送通道的元素值，一定会先被接收。
* 接送操作符: <- 。发送和接收都会用到。



### 发送数据 
在通道值有效的前提下，针对它的发送操作会在通道值已满（其中缓存的数据的个数已等于它的长度）时被阻塞。  
元素值从外界进入通道时会被复制，是接收操作符右边元素的副本
```
ch1 <- "value1"
```


### 接收数据
针对有效通道值的接收操作会在它已空（其中没有缓存任何数据）时被阻塞。  
元素值从通道进入外界：先生成正在通道中的这个元素的副本，并准备给到接收方，然后删除通道中的这个元素。
```
value := <-ch1
value, ok := <-ch1 // 变量ok的值是bool类型,代表通道值的状态，true代表通道值有效，false则代表通道值已无效（或称已关闭）。
```
如果在接收操作进行之前或过程中通道值被关闭了，则接收操作会立即结束并返回一个该通道值的元素类型的零值。



### 关闭通道
对于一个已经初始化未关闭的通道，收发操作一定不会引发 panic。
* 对通道值的重复关闭会引发运行时恐慌。这会使程序崩溃。所以一定要避免这种情况的发生。    
* 向一个已被关闭的通道值发送数据会引发运行时恐慌。
* 如果通道关闭时，里面还有元素值未被取出，那么接收表达式的第一个结果，仍会是通道中的某一个元素值，而第二个结果值一定会是true。
  * 通过接收表达式的第二个结果值，来判断通道是否关闭是可能有延时的。由于通道的收发操作有上述特性，所以除非有特殊的保障措施，我们千万不要让接收方关闭通道，而应当让发送方关闭通道。
```
close(ch1)  
```



### 单向通道
在编写类型声明的时候，可以声明为单向通道。注：初始化一个通道值的时候不能指定它为单向。  
单向通道的主要作用是约束程序对通道值的使用方式。我们调用一个函数时给予它一个发送通道作为参数，以此来约束它只能向该通道发送数据。一个函数将一个接收通道作为结果返回，以此来约束调用该函数的代码只能从这个通道中接收数据。
```
// 单向接收通道：只可从中接收数据的单向通道类型
type Receiver <-chan int 
var ch1 = make(<-chan int, 1)
```

```
// 单向发送通道
type Sender chan<- int 
var ch1 = make(chan<- int, 1)
```


### 通道发送接收基本特性
* 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。
  * 对于通道中的同一个元素来说，发送操作和接收操作之间是互斥的。
* 发送操作和接收操作中对元素值的处理都是不可分割的。
  * 处理元素值时都是一气呵成的，绝不会被打断。
* 发送操作在完全完成之前会被阻塞，接收操作也是如此。


### 通道阻塞
* 如果通道已满，所有发送操作都会被阻塞，直到通道中元素被取走。
  * 通道会优先通知最早因此等待的，那个发送操作的 goroutine，再次执行发送操作。
  * 发送操作被阻塞后，他们所在的 goroutine 会顺序地进入通道内部的发送等待队列，通知顺序总是公平的。
* 如果通道已空，所有的接收操作都会被阻塞，直到通道中有新元素出现。
  * 通道会通知最早等待接收操作所在的 goroutine，再次执行接收操作。
* 对于非缓冲通道，只有配对的发送接收操作开始执行，才会传递，否则阻塞。非缓冲通道是在用同步的方式传递数据。
  * 当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。
  * 数据是直接从发送方复制到接收方，中间并不会用非缓冲通道做中转。
* 对于值为nil的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。
  * 只声明该类型的变量但没有用make函数对它进行初始化时，该变量的值就会是nil。一定要初始化通道。 







