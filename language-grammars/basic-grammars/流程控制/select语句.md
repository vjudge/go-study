# select语句

select 语句属于条件分支流程控制方法，只能用于通道。它可以包含若干条 case 语句，并根据条件选择其中的一个执行。select 语句中的 case 关键字只能后跟用于通道的发送操作的表达式以及接收操作的表达式或语句。

select 会随机执行一个可运行的 case 。每个 case 必须是一个通信操作，要么是发送要么是接收。如果没有 case 可运行，它将阻塞，直到有 case 可运行。

```
// 如果该select语句被执行时通道ch1和ch2中都没有任何数据，那么只有default case会被执行。
// 如果在当时有数据的通道多于一个，那么Go语言会通过一种伪随机的算法来决定哪一个case将被执行。
ch1 := make(chan int, 1)
ch2 := make(chan int, 1)
select { // 不停的在这里检测
    case e1 := <-ch1: // 候选分支: 检测有没有数据可以读
        //如果chanl成功读取到数据，则进行该case处理语句
        fmt.Printf("1th case is selected. e1=%v.\n", e1)
    case ch2 <- 1: // 检测有没有可以写
        //如果成功向chan2写入数据，则进行该case处理语句
        fmt.Printf("2th case is selected. e2=%v.\n", e2)
    default: // 默认分支：假如没有default，那么在以上两个条件都不成立的情况下，就会在此阻塞 //一般default会不写在里面，select中的default子句总是可运行的，因为会很消耗CPU资源
        fmt.Println("No data!") //如果以上都没有符合条件，那么则进行default处理流程
} 
```

如果一条select语句中不存在default case， 并且在被执行时其中的所有 case 都不满足执行条件，那么它的执行将会被阻塞！当前流程的进行也会因此而停滞。直到其中一个 case 满足了执行条件，执行才会继续。

未被初始化的通道会使操作它的 case 永远满足不了执行条件。对于针对它的发送操作和接收操作来说都是如此。

break 语句也可以被包含在 select 语句中的 case 语句中。它的作用是立即结束当前的 select 语句的执行，不论其所属的 case 语句中是否还有未被执行的语句。


### 使用select语句需要注意的点
* 如果像上述示例那样加入了默认分支，那么无论涉及通道操作的表达式是否有阻塞，select语句都不会被阻塞。如果那几个表达式都阻塞了，或者说都没有满足求值的条件，那么默认分支就会被选中并执行。
* 如果没有加入默认分支，那么一旦所有的case表达式都没有满足求值条件，那么select语句就会被阻塞。直到至少有一个case表达式满足条件为止。 
* 我们可能会因为通道关闭了，而直接从通道接收到一个其元素类型的零值。所以，在很多时候，我们需要通过接收表达式的第二个结果值来判断通道是否已经关闭。一旦发现某个通道关闭了，我们就应该及时地屏蔽掉对应的分支或者采取其他措施。这对于程序逻辑和程序性能都是有好处的。
* select语句只能对其中的每一个case表达式各求值一次。所以，如果我们想连续或定时地操作其中的通道的话，就往往需要通过在for语句中嵌入select语句的方式实现。但这时要注意，简单地在select语句的分支中使用break语句，只能结束当前的select语句的执行，而并不会对外层的for语句产生作用。这种错误的用法可能会让这个for语句无休止地运行下去。



### select 分支规则
* 对于每一个case表达式，都至少会包含一个代表发送操作的发送表达式或者一个代表接收操作的接收表达式，同时也可能会包含其他的表达式。比如，如果case表达式是包含了接收表达式的短变量声明时，那么在赋值符号左边的就可以是一个或两个表达式，不过此处的表达式的结果必须是可以被赋值的。当这样的case表达式被求值时，它包含的多个表达式总会以从左到右的顺序被求值。
* select语句包含的候选分支中的case表达式都会在该语句执行开始时先被求值，并且求值的顺序是依从代码编写的顺序从上到下的。结合上一条规则，在select语句开始执行时，排在最上边的候选分支中最左边的表达式会最先被求值，然后是它右边的表达式。仅当最上边的候选分支中的所有表达式都被求值完毕后，从上边数第二个候选分支中的表达式才会被求值，顺序同样是从左到右，然后是第三个候选分支、第四个候选分支，以此类推。
* 对于每一个case表达式，如果其中的发送表达式或者接收表达式在被求值时，相应的操作正处于阻塞状态，那么对该case表达式的求值就是不成功的。在这种情况下，我们可以说，这个case表达式所在的候选分支是不满足选择条件的。
* 仅当select语句中的所有case表达式都被求值完毕后，它才会开始选择候选分支。这时候，它只会挑选满足选择条件的候选分支执行。如果所有的候选分支都不满足选择条件，那么默认分支就会被执行。如果这时没有默认分支，那么select语句就会立即进入阻塞状态，直到至少有一个候选分支满足选择条件为止。一旦有一个候选分支满足选择条件，select语句（或者说它所在的 goroutine）就会被唤醒，这个候选分支就会被执行。
* 如果select语句发现同时有多个候选分支满足选择条件，那么它就会用一种伪随机的算法在这些分支中选择一个并执行。注意，即使select语句是在被唤醒时发现的这种情况，也会这样做。
* 一条select语句中只能够有一个默认分支。并且，默认分支只在无候选分支可选时才会被执行，这与它的编写位置无关。
* select语句的每次执行，包括case表达式求值和分支选择，都是独立的。不过，至于它的执行是否是并发安全的，就要看其中的case表达式以及分支中，是否包含并发不安全的代码了。











