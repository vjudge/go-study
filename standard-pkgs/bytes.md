# bytes

主要处理字节和字节切片



### bytes.Buffer
作为字节序列的缓冲区，具备读写功能

可以拼接、截断其中的字节序列，以各种形式导出其中的内容，还可以顺序地读取其中的子序列

已读计数：代表已读字节数。但无法通过 bytes.Buffer 提供的方法计算出来



### bytes.Buffer.len()
Buffer值的长度是未读内容的长度，而不是已存内容的总长度



### bytes.Buffer.cap()
Buffer值的容量指的是它的内容容器（也就是那个字节切片）的容量，它只与在当前值之上的写操作有关，并会随着内容的写入而不断增长



### bytes.Buffer 扩容策略
两种方式扩容策略基本一致
* 手动扩容
* 自动扩容

扩容策略
* 在扩容的时候，Buffer值中相应的代码（以下简称扩容代码）会先判断内容容器的***剩余容量***，是否可以满足调用方的要求，或者是否足够容纳新的内容
  * 如果可以，那么扩容代码会在当前的内容容器之上，进行长度扩充。如果内容容器的容量与其长度的差，大于或等于另需的字节数，那么扩容代码就会通过切片操作对原有的内容容器的长度进行扩充
  * 如果内容容器的剩余容量不够了，那么扩容代码可能就会用新的内容容器去替代原有的内容容器，从而实现扩容
    * 如果当前内容容器的容量的一半，仍然大于或等于其现有长度（即未读字节数）再加上另需的字节数的和 (cap(b.buf)/2 >= b.Len() + need)。扩容代码就会复用现有的内容容器，并把容器中的未读内容拷贝到它的头部位置。
      * 已读内容，将会全部被未读内容和之后的新内容覆盖掉
    * 当前内容容器的容量小于新长度的二倍
      * 扩容代码就再创建一个新的内容容器，并把原有容器中的未读内容拷贝进去，最后再用新的容器替换掉原有的容器。这个新容器的容量将会等于原有容量的二倍再加上另需字节数的和。新容器的容量 =2* 原有容量 + 所需字节数
  * 为了内部数据的一致性，以及避免原有的已读内容可能造成的数据混乱，扩容代码还会把已读计数置为0，并再对内容容器做一下切片操作，以掩盖掉原有的已读内容





### bytes.Buffer 已读计数
* 读取内容时，相应方法会依据已读计数找到未读部分，并在读取后更新计数
* 写入内容时，如需扩容，相应方法会根据已读计数实现扩容策略
* 截断内容时，相应方法截掉的是已读计数代表索引之后的未读部分
* 读回退时，相应方法需要用已读计数记录回退点
* 重置内容时，相应方法会把已读计数置为 0
* 导出内容时，相应方法只会导出已读计数代表的索引之后的未读部分
* 获取长度时，相应方法会依据已读计数和内容容器的长度，计算未读部分的长度并返回





