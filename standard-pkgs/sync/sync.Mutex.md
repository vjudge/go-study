# sync.Mutex
互斥量（mutual exclusion，简称 mutex）。sync包中的Mutex就是与其对应的类型，该类型的值可以被称为互斥量或者互斥锁。



### 互斥锁
一个互斥锁可以被用来保护一个临界区或者一组相关临界区。我们可以通过它来保证，在同一时刻只有一个 goroutine 处于该临界区之内。

使用互斥锁的注意事项如下：
* 不要重复锁定互斥锁
  * 对一个已经被锁定的互斥锁进行锁定，是会立即阻塞当前的 goroutine。这个 goroutine 所执行的流程，会一直停滞在调用该互斥锁的Lock方法的那行代码上。
* 不要忘记解锁互斥锁，必要时使用defer语句
  * 如果一个流程在锁定了某个互斥锁之后分叉了，或者有被中断的可能，那么就应该使用 defer 语句来对它进行解锁，而且 defer 语句应该紧跟在锁定操作之后。这是最保险的一种做法。
* 不要对尚未锁定或者已解锁的互斥锁解锁
  * 解锁未锁定的互斥锁会立即引发 panic
* 不要在多个函数之间直接传递互斥锁
  * 把一个互斥锁同时用在了多个地方，就必然会有更多的 goroutine 争用这把锁



### 读写锁
* 在写锁已被锁定的情况下再试图锁定写锁，会阻塞当前的 goroutine
* 在写锁已被锁定的情况下试图锁定读锁，也会阻塞当前的 goroutine
* 在读锁已被锁定的情况下试图锁定写锁，同样会阻塞当前的 goroutine
* 在读锁已被锁定的情况下再试图锁定读锁，并不会阻塞当前的 goroutine


### 死锁
指的就是当前程序中的主 goroutine，以及我们启用的那些 goroutine 都已经被阻塞

一旦产生死锁，程序必然崩溃

Go 语言运行时只要它发现所有的用户级 goroutine 都处于等待状态，就会自行抛出一个 panic
```
fatal error: all goroutines are asleep - deadlock!
```



### sync.Mutex
该类型是一个结构体类型，属于值类型中的一种。  
把它传给一个函数、将它从函数中返回、把它赋给其他变量、让它进入某个通道都会导致它的副本的产生  
如果你把一个互斥锁作为参数值传给了一个函数，那么在这个函数中对传入的锁的所有操作，都不会对存在于该函数之外的那个原锁产生任何的影响








一旦数据被多个线程共享，那么就很可能会产生争用和冲突的情况。这种情况也被称为竞态条件（race condition），这往往会破坏共享数据的一致性



















